   version: '3.8'
   services:
     app:
       build: .
       container_name: middleware_app
       ports:
         - "8080:8080"
       volumes:
         - .:/app
       depends_on:
         - database

     database:
       image: mysql:latest
       container_name: middleware_db
       environment:
         MYSQL_ROOT_PASSWORD: root
         MYSQL_DATABASE: mydb
       ports:
         - "3306:3306"

---

// app.js, which fetches data from your Spring Boot backend when the button is clicked. Let me know if you need any changes or enhancements! ðŸš€

document.addEventListener("DOMContentLoaded", () => {
    const button = document.getElementById("fetchData");
    const dataParagraph = document.getElementById("data");

    button.addEventListener("click", async () => {
        try {
            const response = await fetch("http://localhost:8080/api/data");
            if (!response.ok) {
                throw new Error("Network response was not ok");
            }
            const data = await response.json();
            dataParagraph.textContent = JSON.stringify(data, null, 2);
        } catch (error) {
            dataParagraph.textContent = "Error fetching data: " + error.message;
        }
    });
});

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N-Tier Java App</title>
    <script defer src="app.js"></script>
</head>
<body>
    <div id="root">
        <h1>Welcome to N-Tier Java Application</h1>
        <button id="fetchData">Fetch Data from Backend</button>
        <p id="data"></p>
    </div>
</body>
</html>


---

> how to update the docker-compose to run the webserver

To run your web server alongside your middleware app and database in Docker Compose, you'll need to add a new service for the web server. Assuming your web server is a simple static file server for `index.html` and `app.js`, you can use **Nginx** or **Node.js (with `http-server`)**.

### Updated `docker-compose.yml`
```yaml
version: '3.8'
services:
  app:
    build: .
    container_name: middleware_app
    ports:
      - "8080:8080"
    volumes:
      - .:/app
    depends_on:
      - database

  database:
    image: mysql:latest
    container_name: middleware_db
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: mydb
    ports:
      - "3306:3306"

  web:
    image: nginx:latest
    container_name: web_server
    volumes:
      - ./web:/usr/share/nginx/html:ro
    ports:
      - "80:80"
    depends_on:
      - app
```

### Explanation of Changes:
1. **Added a `web` service**:  
   - Uses the **Nginx** official image.
   - Mounts the `./web` directory (where your `index.html` and `app.js` should be stored) to `/usr/share/nginx/html` inside the container.
   - Runs on port **80**.

2. **Directory Structure:**
   ```
   /project-root
   â”œâ”€â”€ docker-compose.yml
   â”œâ”€â”€ web/
   â”‚   â”œâ”€â”€ index.html
   â”‚   â”œâ”€â”€ app.js
   â”œâ”€â”€ backend/ (Spring Boot app)
   â”‚   â”œâ”€â”€ src/
   â”‚   â”œâ”€â”€ Dockerfile
   ```

### Alternative: Using `http-server` (Node.js)
If you want a lightweight server using Node.js, update the `docker-compose.yml` like this:

```yaml
  web:
    image: node:latest
    container_name: web_server
    working_dir: /web
    volumes:
      - ./web:/web
    command: npx http-server -p 80
    ports:
      - "80:80"
    depends_on:
      - app
```
This method uses `http-server` to serve your frontend files.

### Running the Updated Setup:
1. Ensure your **web files** (`index.html` and `app.js`) are in the `web/` directory.
2. Start the services:
   ```sh
   docker-compose up --build
   ```
3. Open **`http://localhost`** in your browser to access the frontend.

Would you like to add SSL support or reverse proxy with Nginx? ðŸš€

---

